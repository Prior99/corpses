/*
 *  This file is part of CORPSES, a webinterface for 7 Days to Die.
 *
 *  CORPSES is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  CORPSES is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with CORPSES. If not, see <http://www.gnu.org/licenses/>.
 */
var Winston = require('winston');
var Events = require('events');
var Util = require("util");
var WS = require("ws");
var FS = require("fs");
var Client = require("./client.js");
var Websocket = require("./websocket_server.js");
var HTTP = require('http');

/**
 * Event that will be fired when something goes wrong.
 * @event Server#error
 */
/**
 * Event that will be fired when the server was stopped.
 * @event Server#stopped
 */
/**
 * Event that will be fired when the server is fully started.
 * @event Server#started
 */

/**
 * This module represents the server that will attach to the 7 Days to Die server,
 * leech it's events and proxy it to the connected clients. It utilizes a database
 * in order to store users and created markers as well as relations between the users.
 * A cache makes sure to keep information from the 7DTD server stored and up-to-date.
 * The constructor takes all necessary and not yet initalized modules it needs
 * to operate. Please start everything after passing it to the server so the
 * respective events can be catched and used.
 * @constructor
 * @param {Cache} cache - an instance of the cache that stores the information of the telnetclient
 * @param {TelnetClient} telnetClient - an instance of the telnetclient connected to the 7DTD server
 * @param {Database} database - an instance of the wrapper for the databaseconnection
 * @param {object} config - the parsed json of the configfile
 * @fires module:Server#started
 * @fires module:Server#error
 */
function Server(cache, telnetClient, database, config) {
	Winston.info("The server is starting...");
	this.config = config;
	this.cache = cache;
	this.telnetClient = telnetClient;
	this.database = database;
	this.wsServer = null;
	this.telnetClient.on("open", function(){
		Winston.info("Connection to 7DTD established.");
		this.telnetClient.triggerListKnownPlayers();
		this.telnetClient.triggerMem();
		this.telnetClient.triggerGetTime();
		this.cache.connectionEstablished(this.telnetClient);
		this.clients = [];
		this._initTelnetClient();
		this._symlinkMap();
		this._startWebsocketServer();
	}.bind(this));
}

Util.inherits(Server, Events.EventEmitter);

Server.prototype._websocketStarted = function() {
	Winston.info("Server up and running!");
	this.emit("started");
};

Server.prototype._symlinkMap = function() {
	var self = this;
	FS.lstat(this.config.clientDirectory + "/map", function(err, stats){
		if(err || !stats.isSymbolicLink()){
			FS.symlink(this.config.mapDirectory, this.config.clientDirectory + "/map", function(err) {
				if(err) {
					if(err.errno !== 47) {
						Winston.error("Unable to create symlink for map.\n" +
							"Please create it manually by executing the following command:\n\n" +
							"ln -s " + this.config.mapDirectory + " " + this.config.clientDirectory + "/map");
						this.emit("error", err);
					}
				}
				else {
					Winston.info("Map successfully linked. (" + this.config.mapDirectory +
						" -> " + this.config.clientDirectory + "/map)");
				}
			}.bind(self));
		}
		else{
			FS.readlink(this.config.clientDirectory + "/map", function(err, link){
				if(err){
					console.log(err);
				}
				else{
					Winston.info("Map link already exists. (" + this.config.clientDirectory + "/map -> " + link + ")");
				}
			}.bind(this));
		}
	}.bind(self));
};

/**
 * Tells this server that a new user connected. A respective "updated" will be broadcasted
 * To each conencted client.
 */
Server.prototype.notifyNewUser = function() {
	this.broadcast("updated", "users");
};

Server.prototype._startWebsocketServer = function() {
	var me = this;
	var portfile = "/*\n * This is an generated file.\n" +
		" * Do not edit this file!\n" +
		" * It will be overwritten on every start of the server.\n" +
		" */\n\n" +
		"var _port = " + this.config.websocketPort + ";\n";
	FS.writeFile(this.config.clientDirectory + "/port.js", portfile, function(err) {
		if(err) {
			Winston.error("Unable to create file \"" +
				this.config.clientDirectory + "/port.js\"." +
				"Please create it manually with the following content:\n" + portfile + "\n");
			this.emit("error", err);
		}
		else {
			this.httpServer = HTTP.createServer();
			this.httpServer.on("error", function(err) {
				Winston.error("The websocketserver could not be started. Is the port maybe in use?");
				this.emit("error", err);
			}.bind(this));
			this.httpServer.listen(this.config.websocketPort, function() {
				this.wsServer = new WS.Server({
					server : this.httpServer
				});
				this.wsServer.on("connection", function(ws) {
					(function(wsc) {
						var client = new Client(wsc, me.database, me);
						me.clients.push(client);
					})(new Websocket(ws));
				});
				Winston.info("Websocketserver started.");
				this._websocketStarted();
			}.bind(this));
		}
	}.bind(this));
};

/**
 * Will remove a client from the list of connected clients.
 * @param {object}  - The client to be removed. If the client is not in the list
 * 				      of known clients, an error will be logged.
 */
Server.prototype.removeClient = function(client) {
	var index;
	if((index = this.clients.indexOf(client)) !== -1) {
		this.clients.splice(index, 1);
		Winston.info("Client disconnected. Currently " + this.clients.length + " clients connected.");
	}
	else {
		Winston.error("Tried to remove client from clients that was not known.");
	}
};

/**
 * Broadcast a message to all clients know to this server. There will be no
 * callback. This is a write-only operation on the websocket.
 * @param {string} name - Name of the event to broadcast to all clients
 * @param {*} obj - The data to broadcast in this event. This may be anything you like.
 */
Server.prototype.broadcast = function(name, obj) {
	for(var i in this.clients) {
		this.clients[i].sendEvent(name, obj);
	}
};

/**
 * This method will broadcast a message to all clients that are logged in as a
 * certain user. This is a write-only operation on the websockets and callbacks
 * are not provided.
 * @param {number} steamid - The steamid of the user to which's clients should
 *                           Be broadcastet to.
 * @param {string} name - The name of the event to broadcast
 * @param {*} obj - The data to broadcast to each client.
 */
Server.prototype.broadcastToUser = function(steamid, name, obj) {
	for(var i in this.clients) {
		var client = this.clients[i];
		if(client.isUser(steamid)) {
			client.sendEvent(name, obj);
		}
	}
};

/**
 * This will return an array of all clients currently connected to the specified
 * user.
 * @param {number} steamid - SteamID of the user to get the clients of.
 * @return {Client[]} Array of all clients connected as this user.
 */
Server.prototype.getUserClients = function(steamid) {
	var list = [];
	for(var i in this.clients) {
		var client = this.clients[i];
		if(client.isUser(steamid)) {
			list.push(client);
		}
	}
	return list;
};

Server.prototype._onChat = function(event) {
	var result;
	if(event.message && (result = event.message.match(/\!m\s+"(.*?)"\s*(?:"(.*?)"\s*(?:(public|private|friends))?)?/))) {
		var name = result[1];
		var description = result[2];
		var visibility = result[3];
		for(var i in this.cache.playersExtended) {
			var player = this.cache.playersExtended[i];
			if(player.name === event.user) {
				this._addMarkerFromChat(player, name, description, visibility);
			}
		}
	}
};


/**
 * Will broadcast the adding of a marker to all users that are authorized
 * to receive this event (depending on visibility and friendships).
 * @param {Database~User} user - User that created the marker.
 * @param {Database~Marker} marker - Marker that will be broadcast.
 * @param {boolean} toSelf - Whether this marker should be sent to own client.
 * @param {Client~VoidCallback} callback - Called when this action has finished
 *										  and all messages were queued to be sent.
 */
Server.prototype.broadcastMarker = function(user, marker, toSelf, callback) {
	var j = this.clients.length;
	var decrease = function() {
		j--;
		if(j === 0) {
			if(callback) { callback(); }
		}
	};
	var sendMarker = function(client) {
		if(client.user.id === user.id) {
			if(toSelf) {
				client.sendMarker(marker);
			}
			decrease();
		}
		else if(marker.visibility === "friends") {
			this.database.areFriends(client.user.id, user.id, function(err, okay) {
				if(!err && okay) {
					client.sendMarker(marker);
				}
				decrease();
			});
		}
		else {
			client.sendMarker(marker);
			decrease();
		}
	}.bind(this);
	for(var i in this.clients) {
		var client = this.clients[i];
		if(client.isLoggedIn()) {
			sendMarker(client);
		}
		else {
			decrease();
		}
	}
};

Server.prototype._addMarkerFromChat = function(player, name, description, visibility) {
	this.database.getUserBySteamID(player.steamid, function(err, user) {
		if(!err && user) {
			var marker = {
				name : name,
				description : description,
				lat : player.position.x,
				lng : player.position.z,
				icon : "thumb-tack",
				visibility : visibility
			};
			this.database.addMarker(marker, user.id, function(err, id) {
				this.broadcastMarker(user, marker, true);
			}.bind(this));
		}
	}.bind(this));
};

Server.prototype._initTelnetClient = function() {
	var me = this;
	this.telnetClient.on("close", function() {
		me.cache.connectionLost();
	});
	this.telnetClient.on("playerConnected", function(evt) {
		if(this.config.kickUnregistered !== undefined && (this.config.kickUnregistered === "true" || this.config.kickUnregistered === true)){
			me.database.getUserBySteamID(evt.steamid, function(err, result){
				if(err === undefined && (result === undefined || result.enabled === 0)){
					me.telnetClient.triggerKickPlayer(evt.name,
						"You must have an enabled account on " +
						(this.config.website === undefined ? "our website": this.config.website) +
						" to play on this server"
					);
				}
				else{
					me.broadcast("playerConnected", evt);
				}
			}.bind(this));
		}
		else {
			me.broadcast("playerConnected", evt);
		}
	}.bind(this));
	this.telnetClient.on("chat", this._onChat.bind(this));
	this.telnetClient.on("playerDisconnected", function(evt) {
		me.broadcast("playerDisconnected", evt);
	});
	this.telnetClient.on("playerSetOnline", function(evt) {
		me.broadcast("playerSetOnline", evt);
	});
	this.telnetClient.on("playerSetOffline", function(evt) {
		me.broadcast("playerSetOffline", evt);
	});
	this.telnetClient.on("spawningWanderingHorde", function(evt) {
		me.broadcast("spawningWanderingHorde", evt);
	});
	this.telnetClient.on("info", function(evt) {
		me.broadcast("updated", "info");
	});
	this.telnetClient.on("listKnownPlayers", function(evt) {
		me.broadcast("updated", "knownPlayers");
	});
	this.telnetClient.on("getTime", function(evt) {
		me.broadcast("updated", "time");
	});
	this.telnetClient.on("listPlayersExtended", function(evt) {
		me.broadcast("updated", "playersExtended");
	});
};

/**
 * This will shutdown the whole server including all subsystems initialized
 * by the server itself or associated with it.
 * If the shutdown succeeds, a "stopped" event will be emitted.
 * @fires module:Server#stopped
 */
Server.prototype.shutdown = function() {
	if(this._dead) {
		return;
	}
	this._dead = true;
	var i = 3;
	var self = this;
	function closed() {
		i--;
		if(i === 0) {
			Winston.info("Server is now down!");
			self.emit("stopped");
		}
	}
	Winston.info("Server is about to shutdown...");
	this.telnetClient.shutdown(function() {
		Winston.info("Connection to 7DTD closed.");
		closed();
	});
	if(this.wsServer && this.httpServer) {
		this.wsServer.close();
		this.httpServer.close(function() {
			Winston.info("Websocketserver closed.");
			closed();
		});
	}
	else {
		closed();
	}
	this.database.shutdown(function() {
		Winston.info("Disconnected from database.");
		closed();
	});
};

module.exports = Server;
